# Inferring the gradient and the Hessian with `CODEML`

Prior to timetree inference with `MCMCtree`, we obtained the **branch lengths** (i.e., vector with estimate branch lengths), the **gradient** (i.e., vector of first derivatives of the likelihood function) and the **Hessian** (i.e., matrix of second derivatives of the likelihood function) for each alignment block with `CODEML`. Note that the aforementioned vectors and matrix are subsequently used to speed up the likelihood calculation in the dating program `MCMCtree` with an approximation technique ([dos Reis and Yang, 2011](https://academic.oup.com/mbe/article/28/7/2161/1051613)).

`CODEML` requires the user to select and input the empirical substitution rate matrix for the chosen evolutionary model that best fits a given alignment block. To this end, the branch lengths, the gradient, and the Hessian are computed for each alignment block under the chosen model separately. Note that, while the `JTT` ([Jones et al. 1992](https://pubmed.ncbi.nlm.nih.gov/1633570/)) and the `LG` ([Le and Gascuel, 2008](https://academic.oup.com/mbe/article/25/7/1307/1041491)) empirical models are summarised in matrices of rate substitution that `CODEML` can use, the current evolutionary models implemented in CODEML for amino acid data do not account for a proportion of invariable sites (i.e., option “+I”). In addition, the documentation of the program does not make it clear whether the AA frequencies can be estimated from the data (i.e., option “+F”) and then incorporated in the substitution rate matrix when computing the branch lengths, the gradient, and the Hessian. Therefore, while we decided to keep the partitioning scheme inferred by `ModelFinder` (i.e., five partition blocks, check our explanation in the [`alignment section` in our GitHub repository](../../00_data/README.md#alignment-files) and the corresponding `Methods` section in our manuscript) for this analysis, we enabled the following settings to define the evolutionary model used to calculate the branch lengths, the gradient, and the Hessian:

* First alignment block, [`JTT+G4+F`, 68 taxa and 25,620 bp](../../00_data/aln/part/JTTG4F.phy), and second alignment block, [`JTT+G4+I`, 68 taxa and 11,212 bp](../../00_data/aln/part/JTTG4I.phy):
  * `aaRatefile = jones.dat`: the rate matrix used corresponds to the `JTT` empirical model. This file can be found in the corresponding `analyses` subdirectories (i.e., [JTTG4F](analyses/JTTG4F/) and [JTTG4I](analyses/JTTG4I/)) as well as in the [`rate_matrix` directory](rate_matrices/jones.dat).
  * `model = 2`: this option instructs `CODEML` to use the empirical model to compute the A frequencies (i.e., the `JTT` empirical model in this case).
* Third alignment block, [`JTT+Mut`, 66 taxa and 7,388 bp](../../00_data/aln/part/JTTMut.phy):
  * `aaRatefile = jones.dat`: given that Kosiol and Goldman ([2005](https://academic.oup.com/mbe/article/22/2/193/963836)) generated a modified version of the JTT substitution rate matrix that integrates the DCMut model (i.e., mutability is accounted for, that is, the rate at which a given amino acid changes to any other amino acid is considered), we could use this matrix to compute the branch lengths, the gradient, and the Hessian of the third alignment block. The rate matrix used corresponds to the `JTT-DCmut` empirical model. This file can be found in both the corresponding `analyses` subdirectory (i.e., [JTTMUT](analyses/JTTMUT/) and [LGI](analyses/LGI/)) as well as in the [`rate_matrix` directory](rate_matrices/jones-dcmut.dat).
  * `model = 2`: this option instructs `CODEML` to use the empirical model to compute the A frequencies (i.e., the `JTT-Mut` empirical model in this case).
* Fourth alignment block, [`LG+F`, 69 taxa and 9,947 bp](../../00_data/aln/part/LGF.phy), and fifth alignment block, [`LG+I`, 70 taxa and 49,102 bp](../../00_data/aln/part/LGI.phy):
  * `aaRatefile = lg.dat`: the rate matrix used corresponds to the `LG` empirical model. This file can be found in the corresponding `analyses` subdirectories (i.e., [LGF](analyses/LGF/) and [LGI](analyses/LGI/)) as well as in the [`rate_matrix` directory](rate_matrices/lg.dat).
  * `model = 2`: this option instructs `CODEML` to use the empirical model to compute the A frequencies (i.e., the `LG` empirical model in this case).

The rest of the settings we enabled are the same for all the alignments:

* Sequence file (`seqfile = tmp0001.txt`), tree file (`treefile = tmp0001.trees`), and output file (`outfile = tmp0001.out`): these files are output when running `MCMCtree` with option `usedata = 3`. In other words, while we are executing `MCMCtree`, this program is only used to read the input files (alignment, tree, and control file) to then output`tmp0001*` files, which will become the input files of `CODEML`: (i) an alignment file with only sequence patterns (`tmp0001.txt`), (ii) a tree file without labels (`tmp0001.trees`), and (iii) the control file to execute `CODEML`. Once these files are generated by `MCMCtree`, the next program that is executed as part of enabling `usedata = 3` is `CODEML`. Note that options `noisy`, `seqtype`, `model`, `aaRatefile`, `fix_alpha`, `alpha`, and `ncatG` (some of them have previously been explained while others will be subsequently explained) are inherited from the input control file one uses to call `MCMCtree` in the first instance. Consequently, it is important to make sure that the values passed to these options are the ones we want to use for branch lengths, gradient, and Hessian calculation.
* Type of sequence data (`seqtype = 2`): this option specifies that the alignment has amino acid sequences.
* Gamma distribution to account for variable substitution rates across sites (`fix_alpha = 0` | `alpha = .5` | `ncatG = 4`): considering that such a deep phylogeny is expected to have a large variation in the evolutionary rate, we decided to account for rate heterogeneity by using the discrete gamma model (Yang 1994) with four categories (`+G4`) for all alignment blocks even if the inferred best-fitting model by ModelFinder did not suggest so. Option `fix_alpha = 0` specifies that the shape parameter $\alpha$ of the Gamma distribution is to be estimated, and the starting value of this search is `alpha = .5`. The number of categories chosen to discretise this distribution is 4 (i.e., `ncatG = 4`).
* Value used in the difference approximation of derivatives (`Small_diff = 0.1e-6`): we have followed the recommendation in the PAML documentation and used a value between 1e-8 and 1e-5. Note that this value is added by default when `MCMCtree` generates the `tmp*` files when run with `usedata = 3`.
* Writing out branch lengths, gradient, and Hessian (`getSE = 2`): this option enable the output of a file called `rst2` where the branch lengths, the gradient, and the Hessian are written out. Note that this value is added by default when `MCMCtree` generates the `tmp*` files when run with `usedata = 3`. If you access the individual subdirectories inside [`analyses`](analyses), you shall see that we renamed this file so that it matches the corresponding directory name: [`JTTG4F_rst2`](analyses/JTTG4F/JTTG4F_rst2), [`JTTG4I_rst2`](analyses/JTTG4I/JTTG4I_rst2), [`JTTMUT_rst2`](analyses/JTTMUT/JTTMUT_rst2), [`LGF_rst2`](analyses/LGF/LGF_rst2), [`LGI_rst2`](analyses/LGI/LGI_rst2).
* Algorithm used to estimate the branch lengths (`method = 1`): this is a more efficient method when substitution parameters are fixed (which is the case here). More details about the algorithm in the PAML documentation, section 10 "Analysing large data sets and iteration algorithm". The output in the `rub` file that `CODEML` will output lists the log likelihood and parameter estimates when this method is enabled given that option `noisy = 3` was used.

In order to proceed with timetree inference, we just had to concatenate the individual `rst2` files in the same order that the corresponding alignment blocks appear in the partitioned alignment (i.e., [`Matrix.phy`](../../00_data/aln/conc/Matrix.phy)). The resulting file, which we called `in.BV`, can be found in the [`01_MCMCtree/inBV` directory](../01_MCMCtree/inBV/in.BV).

## Reproducibility

----

Please note that our manuscript is currently under review, and so we will include a link to download all the output files obtained when running `MCMCtree` at the end of this process. In the meantime, please find below the guidelines required to reproduce all our analyses under a directory called `analyses`, which you shall have access to at the end of the review process. Nevertheless, we have included all the template files and scripts we used to run `MCMCtree`, and so you can run your own analyses too without requiring our output files! Please take a look at the [`02_MCMC_diagnostics`](../../02_MCMC_diagnostics/) directory for more details on [the file structure we followed under the `analyses` directory](../../02_MCMC_diagnostics/README.md#file-structure) in case you also want to follow that -- you will need that if you are to follow the guidelines below!

----

To reproduce our branch lengths, gradient, and Hessian calculations, you will need to make sure that you have PAML v4.9i installed. Otherwise, you shall expect some numerical differences due to the fact that some algorithms may have changed from the version we used to the latest one available at the time of writing (i.e., PAML v4.10.7).

To re-run these analyses, please go to the `analyses` directory and execute the `mcmctree.ctl` files inside each subdirectory. First, however, make sure that you change the `seed = -1` to the number you will see inside each of the `SeedUsed` files that were generated for each individual alignment block. This will make sure that any heuristics algorithm starts with the same starting values. We ran these analyses in an Ubuntu machine so, if you run your analyses in a different operating system, you may however get some differences in the inferred values. To avoid the output files being rewritten (i.e., default option in PAML programs), you may want to generate a different directory with only the input files (i.e., control file, sequence file, tree file, and rate matrix file).

Alternatively, we have provided users with control files to calculate the branch lengths, the gradient, and the Hessian for each alignment block with `CODEML`, which can be done in two different ways:

* Generating `tmp*` input files with `MCMCtree` + running `CODEML`: there is one `mcmctree.ctl` file for each analysis in the subdirectories inside [directory `control_files`](control_files). In these control files, you will see that `userdata = 3` is enabled, `SeedUsed` equals to the seed number we obtained for each analysis, and the path to the input files and rate matrices are now relative paths to the files that you will find in the corresponding subdirectories inside the [`analyses` directory](analyses). If you execute these control files, you will get the `tmp*` input files output by `MCMCtree` and the `rst2` files with the calculated branch lengths, gradient, and Hessian for each alignment block.
* Running `CODEML`: instead of regenerating the `tmp*` input files, you can also just run the `tmp0001.ctl` files in the subdirectories inside [directory `control_files`](control_files) if you already have `tmp*` files available. If you execute these control files with `CODEML` (not `MCMCtree`!), you will then obtain the `rst2` files with the calculated branch lengths, gradient, and Hessian.

**What do we suggest?** We would recommend that you execute `MCMCtree` first, obtain the `tmp*` files and, as soon as these files are generated, kill the job. Please note that there are some options in the `mcmctree.ctl` that will have no effect whatsoever when running `CODEML` as these are settings only used by `MCMCtree` (e.g., relaxed-clock model options, MCMC settings, rate prior, etc.), and thus are ignored when executing `MCMCtree` with `userdata = 3` to just generate these `tmp*` files (and, as soon as this happens, the program is to be killed). Once you have the `tmp0001.ctl` file, you need to make sure that all the options are correctly specified prior to running `CODEML` (e.g., using the terminal, a bash script on your PC or HPC, etc.; you may use something like `codeml tmp0001.ctl` to execute the program to calculate the branch lengths, the gradient, and the Hessian). **Why would this two-step procedure be useful?**

* Option `method` is sometimes automatically set to `method = 0`, and thus you may want to check this option in the output `tmp0001.ctl` before calculating the branch lengths, the gradient, and the Hessian. If you do not have `method = 1`, you can use bash scripting to replace `method = 0` with `method =1`. As explained in the [PAML documentation](https://github.com/abacus-gene/paml/blob/master/doc/pamlDOC.pdf) (at the time of writing, page 56), the iteration algorithm enabled when setting `method = 1` is much more efficient with large datasets than the algorithm enabled when setting `method = 0`, which is exactly what we wanted for our dataset.
* You may have forgotten to specify option `aaRatefile` in the `MCMCtree` control file if you have protein data or you may have made a mistake with another option. If so, please use bash scripting or your favourite text editor to add this option and the absolute or relative path to the file containing the matrix that you want to use.
* You have a large phylogenomic dataset and, by running one analysis after the other, the HPC that you use may kill the job before `CODEML` finishes to calculate the branch lengths, the gradient, and the Hessian.
